#' Generate module 1 Query
#'
#' This function generates a SQL query for module 4 based on the specified tier for BQ2 population(production, staging, or development).
#' It connects to Google's BigQuery, retrieves schema information, and builds a SQL query to fetch non-PII (Personally Identifiable Information) data.
#' 
#' @param tier Character string specifying the environment: 'prod' for production, 'stg' for staging, and 'dev' for development.
#' If none of these are matched, 'unknown-environment' is returned.
#'
#' @return A SQL query string for fetching module 4 data is written to an output file named 'module1.sql' in the corresponding tier directory.
#'
#' @details 
#' The function performs the following steps:
#' 1. Sets up the project ID based on the provided tier.
#' 2. Authenticates to BigQuery.
#' 3. Connects to the BigQuery database.
#' 4. Retrieves the data dictionary and schema information.
#' 5. Builds and writes the SQL query to the output file.
#'
#' @examples
#' generate_module1_query("prod")
#'
#' @author Jing Wu, Jake Peters, Rebecca Sansale
#'
generate_module4_query <- function(tier){
  
project <- switch(tier,
                    prod = "nih-nci-dceg-connect-prod-6d04",
                    stg  = "nih-nci-dceg-connect-stg-5519",
                    dev  = "nih-nci-dceg-connect-dev",
                    "unknown-environment"  # Default value if none of the cases match
)
  
library(bigrquery)
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)
library(tibble)

get_last_cid <- function(compound_cid_name) {
  require(dplyr)
  # get vector of string fragments that are numbers, i.e, no "D_" or "_d_" etc.
  cid_vector <- strsplit(compound_cid_name, '[^0-9]') %>%
    lapply(function(x) {x[!x == ""]} ) %>% # remove empty strings
    unlist()                               # convert from list to character
  last_cid <- cid_vector[length(cid_vector)] 
}

# Authenticate to BigQuery
bq_auth()
  
note <- "Note:
      This SQL query was generated by generate_bq2_queries.qmd. This code 
      lives in a GitHub repo (https://github.com/Analyticsphere/bq2). The 
      code was written by Jing Wu and edited by Jake Peters. The BQ2 tables 
      that are generated in this query are currated and maintained by Jake 
      Peters, Jing Wu and Rebecca Sansale. Other details will be documented here.."
  
#connect to BQ
con <- dbConnect(
    bigrquery::bigquery(),
    project = project,
    dataset = "FlatConnect",
    billing = project
)
  

# Get list of recruitment variables from the participants table
recr_var <- 
  bq_project_query(
    project, 
    query = glue(
      "SELECT * 
       FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
       WHERE table_name='participants_JP'")
    )
recrvar          <- bigrquery::bq_table_download(recr_var, bigint = "integer64")
#recrvar_d        <- recrvar[grepl("d_|D_",recrvar$column_name),]
recrvar$last.CID <- lapply(recrvar$field_path, get_last_cid)

# Get the Concept IDs from the participants table that contain PII
pii_cid     <- y$conceptId.3[which(y$PII == "Yes")]




# Get updated data dictionary
urlfile <- 
"https://raw.githubusercontent.com/episphere/conceptGithubActions/master/csv/masterFile.csv" 
y <- read.csv(urlfile)

flatdatasets <- c("module4_v1_JP")
dt_pii <- NULL
schema <- list()
for (table_name in flatdatasets) {
  sql <- 
      glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name}'")
  query <- bq_project_query(project, query = sql)
  schem <- bq_table_download(query, 
                             bigint="integer64", n_max = Inf, 
                             page_size = 500, quiet = TRUE)
  schem$last.CID <- lapply(schem$field_path, get_last_cid)
  schema[[table_name]] <- schem


  schem_pii <- schem$column_name[which(schem$last.CID %in% pii_cid)] # PII
  print(c(table_name,length(schem_pii)))
  query_vars <- 
    schem$column_name[which(schem$column_name %nin% schem_pii)] # non-PII 
   
  if(length(schem_pii) == 0) {
    tmp             <- as.data.frame(unique(schem$table_name))
    tmp$column_name <- " "
    tmp$last.CID    <- NA
    colnames(tmp)   <- c("table_name","column_name","last.CID")
  } else {
    tmp <- filter(schem,column_name %in% schem_pii) %>%
           select(table_name,column_name,last.CID)
  }
  dt_pii <- rbind(dt_pii,tmp) 
}
dt_pii <- unnest(dt_pii, cols = c(last.CID)) # last.CID is a list, simplify it

# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- 
  rio::import(
    "https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
    format = "json")
dd  <- dplyr::bind_rows(dictionary, .id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), 
                              dd$`Variable Name`, 
                              dd$`Variable Label`)


# dt_pii is the schema table with the PII
# Add PII information to the simple data dictionary
dt_pii_dd <- merge(dt_pii, dd, by.x = "last.CID", by.y = "CID", all.x = TRUE)
# Filter out PII variables from CSV Dictionary-- also removes the additional lines
# between the variables (CID 3)
y_pii     <- filter(y, PII != "") 


pii           <- paste(dt_pii_dd$column_name[
                       which(dt_pii_dd$table_name == "module4_v1_JP")],
                       collapse = ",")
schem_m4      <- schema[["module4_v1_JP"]]
m4_vars.nopii <- schem_m4$column_name[which(schem_m4$column_name %nin% pii)]
select_m4     <- paste(m4_vars.nopii, collapse = ", \n\tm4.")

description_str <- 
  "Objective:
  
      Select all non-PII variables from Module 4.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"

# Construct the parameterized query
query <- glue(
              "
              /*
              {description_str}
              
              {note}
              */
              
              SELECT m4.{select_m4}) 
               FROM `{project}.FlatConnect.module4_v1_JP` b
              INNER JOIN `{project}.FlatConnect.participants_JP` p 
                 ON cast(b.Connect_ID as int64) = cast(p.Connect_ID as int64)
              WHERE p.d_821247024 = '197316935' 
                AND p.d_747006172 != '353358909'")

# Save the query to file
write(query, file = glue("{outputpath}/{tier}/module4.sql"))
}