---
title: "BQ2_table_SQL"
date-modified: 12/05/2023
author: Jing Wu
format: html
editor: visual
---

# Generate SQL queries for BQ2 via R

### Load dependencies

```{r}
library(bigrquery)
library(data.table)
library(boxr)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)

# Get the last concept id from a given compound variable name
# e.g., d_123456789_d_987654321_d_567891234 --> 567891234
get_last_cid <- function(compound_cid_name){
  require(dplyr)
  # get vector of string fragments that are numbers, i.e, no "D_" or "_d_" etc.
  cid_vector <- strsplit(compound_cid_name,'[^0-9]') %>%
    lapply(function(x){x[!x ==""]}) %>% # remove empty strings
    unlist()                            # convert from list to character
  last_cid <- cid_vector[length(cid_vector)] 
}
```

### Generate list of PII/non-PII variables from participants table

```{r}
# Set parameters
project    <- "nih-nci-dceg-connect-prod-6d04"
outputpath <- "data/"


# Get updated data dictionary
urlfile <- "https://raw.githubusercontent.com/episphere/conceptGithubActions/master/csv/masterFile.csv" 
y <- read.csv(urlfile) # TODO: Choose a better name for the Data Dictionary

# Get list of recruitment variables from the participants table
recr_var <- 
  bq_project_query(project, 
                   query = glue(
                        "SELECT * 
                         FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
                         WHERE table_name='participants_JP'"))
recrvar          <- bigrquery::bq_table_download(recr_var, bigint = "integer64")
recrvar_d        <- recrvar[grepl("d_|D_",recrvar$column_name),]
recrvar$last.CID <- lapply(recrvar$field_path, get_last_cid)

# Get the Concept IDs from the participants table that contain PII
pii_cid     <- y$conceptId.3[which(y$PII == "Yes")]
recrvar_pii <- recrvar$column_name[which(recrvar$last.CID %in% pii_cid)] 
parts_vars  <- recrvar$column_name[which(recrvar$column_name %nin% recrvar_pii)] # no PII
txt         <- paste(recrvar_pii, collapse = ",")
select      <- paste(parts_vars,collapse=",")
query       <- glue("SELECT {select} 
                     FROM  `{project}.FlatConnect.participants_JP`  
                     WHERE d_512820379 = '197316935' )")
# write.table(query,file=paste(outputpath,"Query_parts_verified_",currentDate,".txt",sep=""))
```

### Connect to BigQuery

```{r}
# write.table(query,file=paste(outputpath,"Query_parts_verified_",currentDate,".txt",sep=""))
 con <- dbConnect(
   bigrquery::bigquery(),
   project = project,
   dataset = "FlatConnect",
   billing = project
 )
```

### Get list of schemas for each data set

```{r}
flatdatasets <- dbListTables(con)
dt_pii <- NULL
schema <- list()
for (i in 1:length(flatdatasets)){
   x     <- flatdatasets[i]
   sql   <- glue("SELECT * 
                  FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
                  WHERE table_name='{x}'")
   query <- bq_project_query(project, query = sql)
   schem <- bq_table_download(query, bigint="integer64", n_max = Inf, page_size = 500)
   schem$last.CID <- lapply(schem$field_path, get_last_cid)
   schema[[i]]    <- schem

   schem_pii <- schem$column_name[which(schem$last.CID %in% pii_cid)] # PII
   print(c(x,length(schem_pii)))
   query_vars <- schem$column_name[which(schem$column_name %nin% schem_pii)] # non-PII 
   
   if(length(schem_pii) ==0) {
       tmp <- as.data.frame(unique(schem$table_name))
       tmp$column_name <- " "
       tmp$last.CID <- NA
       colnames(tmp) <- c("table_name","column_name","last.CID")
   } else {
       tmp <- filter(schem,column_name %in% schem_pii) %>% 
              select(table_name,column_name,last.CID)
   }
   dt_pii <- rbind(dt_pii,tmp) 
}
```

### Get the JSON version of the Data Dictionary

```{r}
# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- rio::import("https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
                          format = "json")
dd         <- dplyr::bind_rows(dictionary,.id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), dd$`Variable Name`, dd$`Variable Label`)
```

### Query the tables that do not have PII

```{r}
# dt_pii is the schema table with the PII
# Add PII information to the simple data dictionary
dt_pii_dd <- merge(dt_pii, dd, by.x="last.CID", by.y="CID", all.x=TRUE)
# Filter out PII variables from CSV Dictionary-- also removes the additional lines
# between the variables (CID 3)
y_pii     <- filter(y, PII !="") 
 
## Display the data without PII
glue("SELECT * {select} 
     FROM  `{project}.FlatConnect.participants_JP` 
     WHERE d_512820379 = '197316935'")

# These tables do not contain any PII at the moment -- In the future build this 
# up dynamically without assuming they don't contain PII. Manual checks are done
# above, but this list is hard-coded.
q_nopii <- c("bioSurvey_v1_JP",
             "menstrualSurvey_v1_JP",
             "covid19Survey_v1_JP",
             "clinicalBioSurvey_v1_JP",
             "module3_v1_JP")
```

### Generate SQL query for each table and write to file

```{r}
# TODO: This type of indexing is dangerous. Explicitly select the items you want.
s.ls     <- c(1, 4, 5, 6, 11)
for (i in s.ls) {
  select <- paste(schema[[i]]$column_name, collapse=", \nb.")  
  table  <- unique(schema[[i]]$table_name)
  sql    <- glue("SELECT b.{select}\np.Connect_ID
                  FROM  `{project}.FlatConnect.{table}` b
                  INNER JOIN `{project}.FlatConnect.participants_JP` p 
                  ON cast(b.Connect_ID as int64) = cast(p.Connect_ID as int64)
                  WHERE p.d_821247024 = '197316935'")
  
   write.table(sql, glue("{outputpath}{table}_BQ2query.txt"), 
               sep = "\t", 
               row.names = F,
               quote = F,
               col.names = F)
}
```

### for the data with PII

```{r}
##specific for the modules with two versions of data based on the M1_version_combined_05022023.R
# TODO: Jing, can you add the code to make V1_only_vars and V2_only_vars available
#       in this script.

# This dt_pii_dd is a combined schema of all of the data sets, including the
# PII column
dt_pii_dd$column_name[which(dt_pii_dd$column_name %in% V1_only_vars)]
dt_pii_dd$column_name[which(dt_pii_dd$column_name %in% V2_only_vars)]

unique(dt_pii_dd$column_name[which(dt_pii_dd$column_name %in% var.matched)])

schem_m2_v1 <- schema[[9]]
schem_m2_v2 <- schema[[10]]

m2_common.vars <- schem_m2_v1$column_name[
  which(schem_m2_v1$column_name %in% schem_m2_v2$column_name)
  ]

m2_v1.only <- schem_m2_v1$column_name[
  which(schem_m2_v1$column_name %nin% m2_common.vars)
  ]

m2_v2.only <- schem_m2_v2$column_name[
  which(schem_m2_v2$column_name %nin% m2_common.vars)
  ]

write.table(paste(m2_common.vars, collapse=",\n"), outputpath,
            "M2_common_variables_11202023.txt", 
            sep = "\t", row.names = F, quote = F)
write.table(paste(m2_v1.only,collapse=", \nv1."), outputpath,
            "M2_V1only_variables_11202023.txt", 
            sep = "\t", row.names = F, quote = F, col.names = F)
write.table(paste(m2_v2.only,collapse=", \nv2."), outputpath,
            "M2_V2only_variables_11202023.txt", 
            sep = "\t", row.names = F, quote = F, col.names = F)

# ?? query_m2 <- 

pii <- paste(dt_pii_dd$column_name[which(dt_pii_dd$table_name =="module4_v1_JP")],
             collapse = ",")
# TODO: Use string rather than integer to subset.. using an integer is risky
# because the table can grow and throw off your referencing.
schem_m4      <- schema[[12]]
m4_vars.nopii <- schem_m4$column_name[which(schem_m4$column_name %nin% pii)]
select_m4     <- paste(m4_vars.nopii, collapse = ", \nm4.")

query <- glue("SELECT {select_m4} 
               FROM `{project}.FlatConnect.module4_v1_JP` b
               INNER JOIN `{project}.FlatConnect.participants_JP` p 
                       ON cast(b.Connect_ID as int64) = cast(p.Connect_ID as int64)
               WHERE p.d_821247024 = '197316935'")

write.table(query, 
            paste0(outputpath,"M4_BQ2query.txt"), 
            sep="\t", row.names = F,quote = F, col.names = F)
```
