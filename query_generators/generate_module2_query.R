
#' Generate module 2 Query
#'
#' This function generates a SQL query for module 2 based on the specified tier for BQ2 population(production, staging, or development).
#' It connects to Google's BigQuery, retrieves schema information, and builds a SQL query to fetch non-PII (Personally Identifiable Information) data.
#' 
#' @param tier Character string specifying the environment: 'prod' for production, 'stg' for staging, and 'dev' for development.
#' If none of these are matched, 'unknown-environment' is returned.
#'
#' @return A SQL query string for fetching module 2 data is written to an output file named 'module1.sql' in the corresponding tier directory.
#'
#' @details 
#' The function performs the following steps:
#' 1. Sets up the project ID based on the provided tier.
#' 2. Authenticates to BigQuery.
#' 3. Connects to the BigQuery database.
#' 4. Retrieves the data dictionary and schema information.
#' 5. Builds and writes the SQL query to the output file.
#'
#' @examples
#' generate_module2_query("prod")
#'
#' @author Jing Wu, Jake Peters, Rebecca Sansale
#'
generate_module2_query <- function(tier){
  
project <- switch(tier,
                    prod = "nih-nci-dceg-connect-prod-6d04",
                    stg  = "nih-nci-dceg-connect-stg-5519",
                    dev  = "nih-nci-dceg-connect-dev",
                    "unknown-environment"  # Default value if none of the cases match
)
  
library(bigrquery)
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)
library(tibble)

get_last_cid <- function(compound_cid_name) {
  require(dplyr)
  # get vector of string fragments that are numbers, i.e, no "D_" or "_d_" etc.
  cid_vector <- strsplit(compound_cid_name, '[^0-9]') %>%
    lapply(function(x) {x[!x == ""]} ) %>% # remove empty strings
    unlist()                               # convert from list to character
  last_cid <- cid_vector[length(cid_vector)] 
}

# Authenticate to BigQuery
bq_auth()
  
note <- "Note:
      This SQL query was generated by generate_bq2_queries.qmd. This code 
      lives in a GitHub repo (https://github.com/Analyticsphere/bq2). The 
      code was written by Jing Wu and edited by Jake Peters. The BQ2 tables 
      that are generated in this query are currated and maintained by Jake 
      Peters, Jing Wu and Rebecca Sansale. Other details will be documented here.."
  
#connect to BQ
con <- dbConnect(
    bigrquery::bigquery(),
    project = project,
    dataset = "FlatConnect",
    billing = project
)
  

# Get list of recruitment variables from the participants table
recr_var <- 
  bq_project_query(
    project, 
    query = glue(
      "SELECT * 
       FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
       WHERE table_name='participants_JP'")
    )
recrvar          <- bigrquery::bq_table_download(recr_var, bigint = "integer64")
#recrvar_d        <- recrvar[grepl("d_|D_",recrvar$column_name),]
recrvar$last.CID <- lapply(recrvar$field_path, get_last_cid)

# Get the Concept IDs from the participants table that contain PII
pii_cid     <- y$conceptId.3[which(y$PII == "Yes")]




# Get updated data dictionary
urlfile <- 
"https://raw.githubusercontent.com/episphere/conceptGithubActions/master/csv/masterFile.csv" 
y <- read.csv(urlfile)

flatdatasets <- c("module2_v1_JP", "module2_v2_JP")
dt_pii <- NULL
schema <- list()
for (table_name in flatdatasets) {
  sql <- 
      glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name}'")
  query <- bq_project_query(project, query = sql)
  schem <- bq_table_download(query, 
                             bigint="integer64", n_max = Inf, 
                             page_size = 500, quiet = TRUE)
  schem$last.CID <- lapply(schem$field_path, get_last_cid)
  schema[[table_name]] <- schem


  schem_pii <- schem$column_name[which(schem$last.CID %in% pii_cid)] # PII
  print(c(table_name,length(schem_pii)))
  query_vars <- 
    schem$column_name[which(schem$column_name %nin% schem_pii)] # non-PII 
   
  if(length(schem_pii) == 0) {
    tmp             <- as.data.frame(unique(schem$table_name))
    tmp$column_name <- " "
    tmp$last.CID    <- NA
    colnames(tmp)   <- c("table_name","column_name","last.CID")
  } else {
    tmp <- filter(schem,column_name %in% schem_pii) %>%
           select(table_name,column_name,last.CID)
  }
  dt_pii <- rbind(dt_pii,tmp) 
}
dt_pii <- unnest(dt_pii, cols = c(last.CID)) # last.CID is a list, simplify it

# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- 
  rio::import(
    "https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
    format = "json")
dd  <- dplyr::bind_rows(dictionary, .id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), 
                              dd$`Variable Name`, 
                              dd$`Variable Label`)


# dt_pii is the schema table with the PII
# Add PII information to the simple data dictionary
dt_pii_dd <- merge(dt_pii, dd, by.x = "last.CID", by.y = "CID", all.x = TRUE)
# Filter out PII variables from CSV Dictionary-- also removes the additional lines
# between the variables (CID 3)
y_pii     <- filter(y, PII != "") 


# Grab the schemas for Module 2 Version 1 and Module 2 Version 2
schem_m2_v1 <- schema[["module2_v1_JP"]]
schem_m2_v2 <- schema[["module2_v2_JP"]]

# Get the vars that are common to both versions
m2_common_vars <- schem_m2_v1$column_name[which(schem_m2_v1$column_name 
                                                %in% schem_m2_v2$column_name)]

# Get the variables that are unique to each version
m2_v1_only     <- schem_m2_v1$column_name[which(schem_m2_v1$column_name 
                                                %nin% m2_common_vars)]

m2_v2_only     <- schem_m2_v2$column_name[which(schem_m2_v2$column_name 
                                                %nin% m2_common_vars)]

# Save text files of these variable lists if desired
if (export_lists_of_variables) {
  
  write.table(paste(m2_common_vars, collapse=",\n"), outputpath,
              "M2_V1only_variables.txt",
              sep = "\t", row.names = F, quote = F)
  
  write.table(paste(m2_v1_only,collapse=", \nv1."), outputpath,
              "M2_V1only_variables.txt",
              sep = "\t", row.names = F, quote = F, col.names = F)
  
  write.table(paste(m2_v2_only,collapse=", \nv2."), outputpath,
              "M2_V2only_variables.txt",
              sep = "\t", row.names = F, quote = F, col.names = F)
}

## BEGIN BUILDING THE MODULE 2 QUERY ##

# Build string of variables to select that are common to both versions,
# unique to v1 and unique to v2
select_dup       <- paste(m2_common_vars, collapse = ", \n\t")
select_m2v1_only <- paste(m2_v1_only, collapse = ", \n\tv1.")
select_m2v2_only <- paste(m2_v2_only, collapse = ", \n\tv2.")

# List individuals who completed both version of Module 2, to be pasted into sql

sql <- glue("SELECT DISTINCT Connect_ID
             FROM `{project}.FlatConnect.module2_v1_JP`
             WHERE Connect_ID IN (
               SELECT DISTINCT Connect_ID
               FROM `{project}.FlatConnect.module2_v2_JP`)")
query <- bq_project_query(project, query = sql)
compl_m2v1_and_m2v2 <- bq_table_download(query, 
                                         bigint="integer64", n_max = Inf, 
                                         page_size = 500, quiet = TRUE)

# Transform the vector into the desired string format to be inserted into SQL
completed_m2v1_and_m2v2 <- 
  paste0("'", paste(compl_m2v1_and_m2v2$Connect_ID, collapse = "',\n\t'"), "'")

description_str <- 
  "Objective:
  
      Merge Module 2 v1/v2. If participants have completed both versions, only 
      the responses to v2 will be included.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"

# Construct parameterized query string
query_string <- glue(
    "
    /*
    {description_str}
    
    {note}
    */
    
    WITH m2_dup AS
    (SELECT 
      {select_dup}, 
      2 as version 
    FROM 
      `{project}.FlatConnect.module2_v2_JP`
    UNION ALL
    SELECT
      {select_dup}, 
      1 as version 
    FROM 
      `{project}.FlatConnect.module2_v1_JP`
    -- Remove participants that completed both v1 & v2 from the table for v1.
    WHERE 
      Connect_ID NOT IN ({completed_m2v1_and_m2v2})
    )
    SELECT 
      -- Select variables that are common to both versions
      dup.*,
      -- Select variables that are unique to v1
      {select_m2v1_only},
      -- Select variables that are unique to v2
      {select_m2v2_only}
    FROM
      m2_dup AS dup
    LEFT JOIN `{project}.FlatConnect.module2_v1_JP` AS v1
      ON dup.Connect_ID = v1.Connect_ID
    LEFT JOIN	`{project}.FlatConnect.module2_v2_JP` AS v2
      ON v2.Connect_ID = coalesce(dup.Connect_ID,v1.Connect_ID)
    INNER JOIN `{project}.FlatConnect.participants_JP` AS p
      ON coalesce(dup.Connect_ID, v1.Connect_ID, v2.Connect_ID) = p.Connect_ID
    WHERE 
      p.d_821247024 = '197316935'      -- is verified 
      AND p.d_747006172 != '353358909' -- has not withdrawn consent ")

# Save the query to file
write(query_string, file = glue("{outputpath}/{tier}/module2.sql"))
}