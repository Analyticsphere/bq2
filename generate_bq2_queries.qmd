---
title: "generate_bq2_queries"
date-modified: Sys.date()
authors: 
  - Jing Wu
  - Jake Peters
format: html
editor: visual
---

# Generate SQL queries for BQ2 via R

### Set script parameters

```{r}
tier       <- "prod"
outputpath <- "sql"
export_lists_of_variables <- FALSE


# Use switch to select the project based on the tier
project <- switch(tier,
  prod = "nih-nci-dceg-connect-prod-6d04",
  stg  = "nih-nci-dceg-connect-stg-5519",
  dev  = "nih-nci-dceg-connect-dev",
  "unknown-environment"  # Default value if none of the cases match
)
```

### Load dependencies

```{r}
library(bigrquery)
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)

# Authenticate to BigQuery
bq_auth()

## User-defined Functions

# Get the last concept id from a given compound variable name
# e.g., d_123456789_d_987654321_d_567891234 --> 567891234
get_last_cid <- function(compound_cid_name) {
  require(dplyr)
  # get vector of string fragments that are numbers, i.e, no "D_" or "_d_" etc.
  cid_vector <- strsplit(compound_cid_name, '[^0-9]') %>%
    lapply(function(x) {x[!x == ""]} ) %>% # remove empty strings
    unlist()                               # convert from list to character
  last_cid <- cid_vector[length(cid_vector)] 
}
```

### Save a description of the query generator process to add to sql code

```{r}
note <- 
  "Note:
      This SQL query was generated by generate_bq2_queries.qmd. This code 
      lives in a GitHub repo (https://github.com/Analyticsphere/bq2). The 
      code was written by Jing Wu and edited by Jake Peters. The BQ2 tables 
      that are generated in this query are currated and maintained by Jake 
      Peters, Jing Wu and Rebecca Sansale. Other details will be documented here.."
```

### Generate list of PII/non-PII variables from participants table

```{r}
# Get updated data dictionary
urlfile <- 
"https://raw.githubusercontent.com/episphere/conceptGithubActions/master/csv/masterFile.csv" 
y <- read.csv(urlfile) # TODO: Choose a better name for the Data Dictionary

# Get list of recruitment variables from the participants table
recr_var <- 
  bq_project_query(
    project, 
    query = glue(
      "SELECT * 
       FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
       WHERE table_name='participants_JP'")
    )
recrvar          <- bigrquery::bq_table_download(recr_var, bigint = "integer64")
recrvar_d        <- recrvar[grepl("d_|D_",recrvar$column_name),]
recrvar$last.CID <- lapply(recrvar$field_path, get_last_cid)

# Get the Concept IDs from the participants table that contain PII
pii_cid     <- y$conceptId.3[which(y$PII == "Yes")]
recrvar_pii <- recrvar$column_name[which(recrvar$last.CID %in% pii_cid)] 
parts_vars  <- recrvar$column_name[which(recrvar$column_name %nin% recrvar_pii)] # no PII
txt         <- paste(recrvar_pii, collapse = ",")
select      <- paste(parts_vars,collapse=",\n")
query       <- glue("SELECT {select} 
                     FROM  `{project}.FlatConnect.participants_JP`  
                     WHERE d_512820379 = '197316935' )")
# write.table(query,file=paste(outputpath,"Query_parts_verified_",
#             currentDate, ".txt", sep=""))
```

### Connect to BigQuery

```{r}
# write.table(query,file=paste(outputpath,"Query_parts_verified_",currentDate,".txt",sep=""))
con <- dbConnect(
  bigrquery::bigquery(),
  project = project,
  dataset = "FlatConnect",
  billing = project
)
```

### Get list of schemas for each data set

```{r}
flatdatasets <- dbListTables(con)
dt_pii <- NULL
schema <- list()
for (table_name in flatdatasets) {
  sql <- 
      glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name}'")
  query <- bq_project_query(project, query = sql)
  schem <- bq_table_download(query, 
                             bigint="integer64", n_max = Inf, 
                             page_size = 500, quiet = TRUE)
  schem$last.CID <- lapply(schem$field_path, get_last_cid)
  schema[[table_name]] <- schem


  schem_pii <- schem$column_name[which(schem$last.CID %in% pii_cid)] # PII
  print(c(table_name,length(schem_pii)))
  query_vars <- 
    schem$column_name[which(schem$column_name %nin% schem_pii)] # non-PII 
   
  if(length(schem_pii) == 0) {
    tmp             <- as.data.frame(unique(schem$table_name))
    tmp$column_name <- " "
    tmp$last.CID    <- NA
    colnames(tmp)   <- c("table_name","column_name","last.CID")
  } else {
    tmp <- filter(schem,column_name %in% schem_pii) %>%
           select(table_name,column_name,last.CID)
  }
  dt_pii <- rbind(dt_pii,tmp) 
}
dt_pii <- unnest(dt_pii, cols = c(last.CID)) # last.CID is a list, simplify it
```

### Get the JSON version of the Data Dictionary

```{r}
# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- 
  rio::import(
    "https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
    format = "json")
dd  <- dplyr::bind_rows(dictionary, .id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), 
                              dd$`Variable Name`, 
                              dd$`Variable Label`)
```

### Query the tables that do not have PII in a loop

```{r}
# dt_pii is the schema table with the PII
# Add PII information to the simple data dictionary
dt_pii_dd <- merge(dt_pii, dd, by.x = "last.CID", by.y = "CID", all.x = TRUE)
# Filter out PII variables from CSV Dictionary-- also removes the additional lines
# between the variables (CID 3)
y_pii     <- filter(y, PII != "") 

# These tables do not contain any PII at the moment -- In the future build this 
# up dynamically without assuming they don't contain PII. Manual checks are done
# above, but this list is hard-coded.
q_nopii <- c("bioSurvey_v1_JP",
             "menstrualSurvey_v1_JP",
             "covid19Survey_v1_JP",
             "clinicalBioSurvey_v1_JP",
             "module3_v1_JP")

# Generate SQL query for each table and write to file

# TODO: This type of indexing is dangerous. Explicitly select the items you want.
for (ith_table in q_nopii) {
  select <- paste(schema[[ith_table]]$column_name, collapse = ", \n\tb.")  
  table  <- unique(schema[[ith_table]]$table_name)
  sql    <- glue(
      "
      /*
      Objective:
        Select all non-PII variables from {table}.
      
        For participants to be included:
         - Verification Status [821247024] MUST BE verified
         - Consent Withdrawn [747006172] MUST NOT be YES [353358909]
       
      {note}
      */
      
      SELECT 
        b.{select} 
        p.Connect_ID
      FROM 
        `{project}.FlatConnect.{table}` b
      INNER JOIN `{project}.FlatConnect.participants_JP` p
        ON cast(b.Connect_ID as int64) = cast(p.Connect_ID as int64)
      WHERE 
        p.d_821247024 = '197316935'      -- is verified
        AND p.d_747006172 != '353358909' -- has not withdrawn consent")
   
   bq2_tbl_name <- gsub("_v1_JP", "", table) # remove the _v1_JP pattern from file name
   write(sql, file = glue("{outputpath}/{tier}/bq2_{bq2_tbl_name}.sql"))

}
```

### Print table names

```{r}
for (i in c(1:length(schema))) {
  dt <- as.data.frame(schema[[i]])
  print(c(i, unique(dt$table_name)))
}
```

### Merge Module 1

```{r}
# Grab the schemas for Module 1 Version 1 and Module 1 Version 2
# schem_m1_v1  <- schema[[7]] #TODO Dangerous integer-based referencing here..
# schem_m1_v2  <- schema[[8]]
schem_m1_v1  <- schema[["module1_v1_JP"]] 
schem_m1_v2  <- schema[["module1_v2_JP"]]

# Get the variables that are common to both versions
m1_common.vars <- schem_m1_v1$column_name[which(schem_m1_v1$column_name 
                                                %in% schem_m1_v2$column_name)]

# Get the variables that are unique to each version
V1_only_vars <- schem_m1_v1$column_name[which(schem_m1_v1$column_name 
                                              %nin% m1_common.vars)]
V2_only_vars <- schem_m1_v2$column_name[which(schem_m1_v2$column_name 
                                              %nin% m1_common.vars)]

# Subset the ones that are PII
v1_only_pii  <- dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                            %in% V1_only_vars)]
v2_only_pii  <- dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                            %in% V2_only_vars)]

# Variables that are common to both versions
var.matched  <- schem_m1_v1$column_name[which(schem_m1_v1$column_name 
                                              %in% schem_m1_v2$column_name)]

# PII variables that are common to both versions
common_pii   <- unique(dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                                   %in% var.matched)])

# Save text files of these variable lists if desired
if (export_lists_of_variables) {
  
  write.table(paste(var.matched, collapse=",\n"),
              glue("{outputpath}/{tier}/m1_common_variables.txt"), 
              sep = "\t", row.names = F, quote = F)
  
  write.table(paste(V1_only_vars, collapse = ", \nv1."),
              glue("{outputpath}/{tier}/m1_v1_only_variables.txt"), 
              sep = "\t", row.names = F, quote = F, col.names = F)
  
  write.table(paste(V2_only_vars, collapse = ", \nv2."),
              glue("{outputpath}/{tier}/m1_v2_only_variables.txt"), 
              sep = "\t", row.names = F, quote = F, col.names = F)
}


## BEGIN BUILDING THE MODULE 1 QUERY ##

# Build string of variables to select that are common to both versions,
# unique to v1 and unique to v2
selectm1_dup     <- paste(var.matched[which(var.matched %nin% common_pii)], 
                          collapse = ",\n\t")
select_m1v1_only <- paste(V1_only_vars[which(V1_only_vars %nin% v1_only_pii)], 
                          collapse = ", \n\tv1.")
select_m1v2_only <- paste(V2_only_vars[which(V2_only_vars %nin% v2_only_pii)],
                          collapse = ", \n\tv2.")

# Get the individuals who completed version 1 and version 2
sql <- glue("SELECT DISTINCT Connect_ID
             FROM `{project}.FlatConnect.module1_v1_JP`
             WHERE Connect_ID IN (
               SELECT DISTINCT Connect_ID
               FROM `{project}.FlatConnect.module1_v2_JP`)")
query <- bq_project_query(project, query = sql)
compl_m1v1_and_m1v2 <- bq_table_download(query, 
                                         bigint="integer64", n_max = Inf, 
                                         page_size = 500, quiet = TRUE)

# Transform the vector into the desired string format to be inserted into SQL
completed_m1v1_and_m1v2 <- 
  paste0("'", paste(compl_m1v1_and_m1v2$Connect_ID, collapse = "',\n\t'"), "'")
# cat(completed_m1v1_and_m1v2)

description_str <- 
    "Objective:
  
      Merge Module 1 v1/v2. If participants have completed both versions, only 
      the responses to v2 will be included.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"

# Construct parameterized query for Module 1
query_a <- glue(
      "
      /*
      {description_str}
      
      {note}
      */

      WITH m1_dup AS
      (SELECT 
        {selectm1_dup}, 
        2 as version 
      FROM `{project}.FlatConnect.module1_v2_JP`
      UNION ALL
      SELECT
        {selectm1_dup},
        1 as version 
      FROM `{project}.FlatConnect.module1_v1_JP`
      -- Remove participants that completed both v1 & v2 from the table for v1.
      WHERE Connect_ID NOT IN 
        ({completed_m1v1_and_m1v2})
      )
      SELECT 
        -- Select variables that are common to both versions
        dup.*, 
        -- Select variables that are unique to version 1
        {select_m1v1_only},
        -- Select variables that are unique to version 2
        {select_m1v2_only},
        p.Connect_ID 
      FROM m1_dup AS dup
      LEFT JOIN `{project}.FlatConnect.module1_v1_JP` AS v1
        ON dup.Connect_ID = v1.Connect_ID
      LEFT JOIN	`{project}.FlatConnect.module1_v2_JP` AS v2
        ON v2.Connect_ID = coalesce(dup.Connect_ID,v1.Connect_ID)
      INNER JOIN `{project}.FlatConnect.participants_JP` AS p
        ON coalesce(dup.Connect_ID, v1.Connect_ID, v2.Connect_ID) = p.Connect_ID
      WHERE 
        p.d_821247024 = '197316935'      -- is verified
        AND p.d_747006172 != '353358909' -- has not widrawn consent")

# Save the query to file
write(query_a, file = glue("{outputpath}/{tier}/bq2_module1.sql"))
```

### Merge Module 2

```{r}
# Grab the schemas for Module 2 Version 1 and Module 2 Version 2
schem_m2_v1 <- schema[["module2_v1_JP"]]
schem_m2_v2 <- schema[["module2_v2_JP"]]

# Get the vars that are common to both versions
m2_common.vars <- schem_m2_v1$column_name[which(schem_m2_v1$column_name 
                                                %in% schem_m2_v2$column_name)]

# Get the variables that are unique to each version
m2_v1.only     <- schem_m2_v1$column_name[which(schem_m2_v1$column_name 
                                                %nin% m2_common.vars)]

m2_v2.only     <- schem_m2_v2$column_name[which(schem_m2_v2$column_name 
                                                %nin% m2_common.vars)]

# Save text files of these variable lists if desired
if (export_lists_of_variables) {
  
  write.table(paste(m2_common.vars, collapse=",\n"), outputpath,
              "M2_V1only_variables.txt",
              sep = "\t", row.names = F, quote = F)
  
  write.table(paste(m2_v1.only,collapse=", \nv1."), outputpath,
              "M2_V1only_variables.txt",
              sep = "\t", row.names = F, quote = F, col.names = F)
  
  write.table(paste(m2_v2.only,collapse=", \nv2."), outputpath,
              "M2_V2only_variables.txt",
              sep = "\t", row.names = F, quote = F, col.names = F)
}

## BEGIN BUILDING THE MODULE 2 QUERY ##

# Build string of variables to select that are common to both versions,
# unique to v1 and unique to v2
select_dup       <- paste(m2_common.vars, collapse = ", \n\t")
select_m2v1_only <- paste(m2_v1.only, collapse = ", \n\tv1.")
select_m2v2_only <- paste(m2_v2.only, collapse = ", \n\tv2.")

# List individuals who completed both version of Module 2, to be pasted into sql

sql <- glue("SELECT DISTINCT Connect_ID
             FROM `{project}.FlatConnect.module2_v1_JP`
             WHERE Connect_ID IN (
               SELECT DISTINCT Connect_ID
               FROM `{project}.FlatConnect.module2_v2_JP`)")
query <- bq_project_query(project, query = sql)
compl_m2v1_and_m2v2 <- bq_table_download(query, 
                                         bigint="integer64", n_max = Inf, 
                                         page_size = 500, quiet = TRUE)

# Transform the vector into the desired string format to be inserted into SQL
completed_m2v1_and_m2v2 <- 
  paste0("'", paste(compl_m2v1_and_m2v2$Connect_ID, collapse = "',\n\t'"), "'")
# cat(completed_m2v1_and_m2v2)

description_str <- 
  "Objective:
  
      Merge Module 2 v1/v2. If participants have completed both versions, only 
      the responses to v2 will be included.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"

# Construct parameterized query string
query_string <- glue(
    "
    /*
    {description_str}
    
    {note}
    */
    
    WITH m2_dup AS
    (SELECT 
      {select_dup}, 
      2 as version 
    FROM 
      `{project}.FlatConnect.module2_v2_JP`
    UNION ALL
    SELECT
      {select_dup}, 
      1 as version 
    FROM 
      `{project}.FlatConnect.module2_v1_JP`
    -- Remove participants that completed both v1 & v2 from the table for v1.
    WHERE 
      Connect_ID NOT IN ({completed_m2v1_and_m2v2})
    )
    SELECT 
      -- Select variables that are common to both versions
      dup.*,
      -- Select variables that are unique to v1
      {select_m2v1_only},
      -- Select variables that are unique to v2
      {select_m2v2_only},
      p.Connect_ID 
    FROM
      m2_dup AS dup
    LEFT JOIN `{project}.FlatConnect.module2_v1_JP` AS v1
      ON dup.Connect_ID = v1.Connect_ID
    LEFT JOIN	`{project}.FlatConnect.module2_v2_JP` AS v2
      ON v2.Connect_ID = coalesce(dup.Connect_ID,v1.Connect_ID)
    INNER JOIN `{project}.FlatConnect.participants_JP` AS p
      ON coalesce(dup.Connect_ID, v1.Connect_ID, v2.Connect_ID) = p.Connect_ID
    WHERE 
      p.d_821247024 = '197316935'      -- is verified 
      AND p.d_747006172 != '353358909' -- has not withdrawn consent ")

# Save the query to file
write(query_string, file = glue("{outputpath}/{tier}/bq2_module2.sql"))
```

### Merge Module 4

```{r}
pii           <- paste(dt_pii_dd$column_name[
                       which(dt_pii_dd$table_name == "module4_v1_JP")],
                       collapse = ",")
schem_m4      <- schema[["module4_v1_JP"]]
m4_vars.nopii <- schem_m4$column_name[which(schem_m4$column_name %nin% pii)]
select_m4     <- paste(m4_vars.nopii, collapse = ", \n\tm4.")

description_str <- 
  "Objective:
  
      Select all non-PII variables from Module 4.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"

# Construct the parameterized query
query <- glue(
              "
              /*
              {description_str}
              
              {note}
              */
              
              SELECT m4.{select_m4}) 
               FROM `{project}.FlatConnect.module4_v1_JP` b
              INNER JOIN `{project}.FlatConnect.participants_JP` p 
                 ON cast(b.Connect_ID as int64) = cast(p.Connect_ID as int64)
              WHERE p.d_821247024 = '197316935' 
                AND p.d_747006172 != '353358909'")

# Save the query to file
write(query, file = glue("{outputpath}/{tier}/bq2_module4.sql"))
```
