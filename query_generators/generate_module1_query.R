#' Generate module 1 Query
#'
#' This function generates a SQL query for module 1 based on the specified tier for BQ2 population(production, staging, or development).
#' It connects to Google's BigQuery, retrieves schema information, and builds a SQL query to fetch non-PII (Personally Identifiable Information) data.
#' 
#' @param tier Character string specifying the environment: 'prod' for production, 'stg' for staging, and 'dev' for development.
#' If none of these are matched, 'unknown-environment' is returned.
#'
#' @return A SQL query string for fetching module 1 data is written to an output file named 'module1.sql' in the corresponding tier directory.
#'
#' @details 
#' The function performs the following steps:
#' 1. Sets up the project ID based on the provided tier.
#' 2. Authenticates to BigQuery.
#' 3. Connects to the BigQuery database.
#' 4. Retrieves the data dictionary and schema information.
#' 5. Builds and writes the SQL query to the output file.
#'
#' @examples
#' generate_module1_query("prod")
#'
#' @author Jing Wu, Jake Peters, Rebecca Sansale
#'
generate_module1_query <- function(tier){
  
project <- switch(tier,
                    prod = "nih-nci-dceg-connect-prod-6d04",
                    stg  = "nih-nci-dceg-connect-stg-5519",
                    dev  = "nih-nci-dceg-connect-dev",
                    "unknown-environment"  # Default value if none of the cases match
)
  
library(bigrquery)
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)
library(tibble)

get_last_cid <- function(compound_cid_name) {
  require(dplyr)
  # get vector of string fragments that are numbers, i.e, no "D_" or "_d_" etc.
  cid_vector <- strsplit(compound_cid_name, '[^0-9]') %>%
    lapply(function(x) {x[!x == ""]} ) %>% # remove empty strings
    unlist()                               # convert from list to character
  last_cid <- cid_vector[length(cid_vector)] 
}

# Authenticate to BigQuery
bq_auth()
  
note <- "Note:
      This SQL query was generated by generate_bq2_queries.qmd. This code 
      lives in a GitHub repo (https://github.com/Analyticsphere/bq2). The 
      code was written by Jing Wu and edited by Jake Peters. The BQ2 tables 
      that are generated in this query are currated and maintained by Jake 
      Peters, Jing Wu and Rebecca Sansale. Other details will be documented here.."
  
#connect to BQ
con <- dbConnect(
    bigrquery::bigquery(),
    project = project,
    dataset = "FlatConnect",
    billing = project
)
  

# Get list of recruitment variables from the participants table
recr_var <- 
  bq_project_query(
    project, 
    query = glue(
      "SELECT * 
       FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
       WHERE table_name='participants_JP'")
    )
recrvar          <- bigrquery::bq_table_download(recr_var, bigint = "integer64")
#recrvar_d        <- recrvar[grepl("d_|D_",recrvar$column_name),]
recrvar$last.CID <- lapply(recrvar$field_path, get_last_cid)

# Get the Concept IDs from the participants table that contain PII
pii_cid     <- y$conceptId.3[which(y$PII == "Yes")]




# Get updated data dictionary
urlfile <- 
"https://raw.githubusercontent.com/episphere/conceptGithubActions/master/csv/masterFile.csv" 
y <- read.csv(urlfile)

flatdatasets <- c("module1_v1_JP", "module1_v2_JP")
dt_pii <- NULL
schema <- list()
for (table_name in flatdatasets) {
  sql <- 
      glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name}'")
  query <- bq_project_query(project, query = sql)
  schem <- bq_table_download(query, 
                             bigint="integer64", n_max = Inf, 
                             page_size = 500, quiet = TRUE)
  schem$last.CID <- lapply(schem$field_path, get_last_cid)
  schema[[table_name]] <- schem


  schem_pii <- schem$column_name[which(schem$last.CID %in% pii_cid)] # PII
  print(c(table_name,length(schem_pii)))
  query_vars <- 
    schem$column_name[which(schem$column_name %nin% schem_pii)] # non-PII 
   
  if(length(schem_pii) == 0) {
    tmp             <- as.data.frame(unique(schem$table_name))
    tmp$column_name <- " "
    tmp$last.CID    <- NA
    colnames(tmp)   <- c("table_name","column_name","last.CID")
  } else {
    tmp <- filter(schem,column_name %in% schem_pii) %>%
           select(table_name,column_name,last.CID)
  }
  dt_pii <- rbind(dt_pii,tmp) 
}
dt_pii <- unnest(dt_pii, cols = c(last.CID)) # last.CID is a list, simplify it

# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- 
  rio::import(
    "https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
    format = "json")
dd  <- dplyr::bind_rows(dictionary, .id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), 
                              dd$`Variable Name`, 
                              dd$`Variable Label`)


# dt_pii is the schema table with the PII
# Add PII information to the simple data dictionary
dt_pii_dd <- merge(dt_pii, dd, by.x = "last.CID", by.y = "CID", all.x = TRUE)
# Filter out PII variables from CSV Dictionary-- also removes the additional lines
# between the variables (CID 3)
y_pii     <- filter(y, PII != "") 

# Grab the schemas for Module 1 Version 1 and Module 1 Version 2
# schem_m1_v1  <- schema[[7]] #TODO Dangerous integer-based referencing here..
# schem_m1_v2  <- schema[[8]]
schem_m1_v1  <- schema[["module1_v1_JP"]] 
schem_m1_v2  <- schema[["module1_v2_JP"]]

#these variables had formatting issues and must be called into the query
#separately and coalesced. see github BQ2 repo issue #4 for more info
#these are only included in module 1 v2
exceptions_m1_v2 <- c(
  "D_150352141_D_623218391", "D_150352141_D_206625031",
  "D_150352141_D_802622485", "D_150352141_D_261863326",
  "D_122887481_D_623218391", "D_122887481_D_206625031",
  "D_122887481_D_802622485", "D_122887481_D_261863326",
  "D_534007917_D_623218391", "D_534007917_D_206625031",
  "D_534007917_D_802622485", "D_534007917_D_261863326",
  "D_752636038_D_623218391", "D_752636038_D_206625031",
  "D_752636038_D_802622485", "D_752636038_D_261863326",
  "D_518750011_D_623218391", "D_518750011_D_206625031",
  "D_518750011_D_802622485", "D_518750011_D_261863326",
  "D_275770221_D_623218391", "D_275770221_D_206625031",
  "D_275770221_D_802622485", "D_275770221_D_261863326",
  "D_527057404_D_623218391", "D_527057404_D_206625031",
  "D_527057404_D_802622485", "D_527057404_D_261863326"
)

# Get the variables that are common to both versions
m1_common_vars <- schem_m1_v1$column_name[which(schem_m1_v1$column_name 
                                                %in% schem_m1_v2$column_name)]

# Get the variables that are unique to each version
V1_only_vars <- schem_m1_v1$column_name[which(schem_m1_v1$column_name 
                                              %nin% m1_common_vars)]
V2_only_vars <- schem_m1_v2$column_name[which(schem_m1_v2$column_name 
                                              %nin% m1_common_vars)]

# Subset the ones that are PII
v1_only_pii  <- dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                            %in% V1_only_vars)]
v2_only_pii  <- dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                            %in% V2_only_vars)]

# PII variables that are common to both versions
common_pii   <- unique(dt_pii_dd$column_name[which(dt_pii_dd$column_name 
                                                   %in% m1_common_vars)])

# Save text files of these variable lists if desired
if (export_lists_of_variables) {
  
  write.table(paste(m1_common.vars, collapse=",\n"),
              glue("{outputpath}/{tier}/m1_common_variables.txt"), 
              sep = "\t", row.names = F, quote = F)
  
  write.table(paste(V1_only_vars, collapse = ", \nv1."),
              glue("{outputpath}/{tier}/m1_v1_only_variables.txt"), 
              sep = "\t", row.names = F, quote = F, col.names = F)
  
  write.table(paste(V2_only_vars, collapse = ", \nv2."),
              glue("{outputpath}/{tier}/m1_v2_only_variables.txt"), 
              sep = "\t", row.names = F, quote = F, col.names = F)
}


## BEGIN BUILDING THE MODULE 1 QUERY ##

# Build string of variables to select that are common to both versions,
# unique to v1 and unique to v2
selectm1_dup     <- paste(m1_common_vars[which(m1_common_vars %nin% common_pii)], 
                          collapse = ",\n\t")
select_m1v1_only <- paste(V1_only_vars[which(V1_only_vars %nin% v1_only_pii)], 
                          collapse = ", \n\tv1.")
select_m1v2_only <- paste(V2_only_vars[which(V2_only_vars %nin% v2_only_pii)],
                          collapse = ", \n\tv2.")

# Get the individuals who completed version 1 and version 2
sql <- glue("SELECT DISTINCT Connect_ID
             FROM `{project}.FlatConnect.module1_v1_JP`
             WHERE Connect_ID IN (
               SELECT DISTINCT Connect_ID
               FROM `{project}.FlatConnect.module1_v2_JP`)")
query <- bq_project_query(project, query = sql)
compl_m1v1_and_m1v2 <- bq_table_download(query, 
                                         bigint="integer64", n_max = Inf, 
                                         page_size = 500, quiet = TRUE)

# Transform the vector into the desired string format to be inserted into SQL
completed_m1v1_and_m1v2 <- 
  paste0("'", paste(compl_m1v1_and_m1v2$Connect_ID, collapse = "',\n\t'"), "'")
# cat(completed_m1v1_and_m1v2)

description_str <- 
    "Objective:
  
      Merge Module 1 v1/v2. If participants have completed both versions, only 
      the responses to v2 will be included.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"
# Transform the flat vector into pairs
v2_exceptions_m1_v2 <- paste0("v2.", exceptions_m1_v2)
variable_pairs <- matrix(v2_exceptions_m1_v2, ncol = 2, byrow = TRUE)

source("./custom_r_functions/create_coalesce_query.R")
# Apply create_coalesce_query to each pair
coalesce_statements <- apply(variable_pairs, 1, function(pair) {
  create_coalesce_query(pair, pair[1])
})

# Concatenate all coalesce statements
coalesce_strings <- paste(coalesce_statements, collapse = ",\n\t")

# Construct parameterized query for Module 1
query_a <- glue(
      "
      /*
      {description_str}
      
      {note}
      */

      WITH m1_dup AS
      (SELECT 
        {selectm1_dup}, 
        2 as version
      FROM `{project}.FlatConnect.module1_v2_JP`
      UNION ALL
      SELECT
        {selectm1_dup},
        1 as version
      FROM `{project}.FlatConnect.module1_v1_JP`
      -- Remove participants that completed both v1 & v2 from the table for v1.
      WHERE Connect_ID NOT IN 
        ({completed_m1v1_and_m1v2})
      )
      SELECT 
        -- Select variables that are common to both versions
        dup.*, 
        -- Select variables that are unique to version 1
        {select_m1v1_only},
        -- Select variables that are unique to version 2
       {coalesce_strings},
        {select_m1v2_only}
      FROM m1_dup AS dup
      LEFT JOIN `{project}.FlatConnect.module1_v1_JP` AS v1
        ON dup.Connect_ID = v1.Connect_ID
      LEFT JOIN	`{project}.FlatConnect.module1_v2_JP` AS v2
        ON v2.Connect_ID = coalesce(dup.Connect_ID,v1.Connect_ID)
      INNER JOIN `{project}.FlatConnect.participants_JP` AS p
        ON coalesce(dup.Connect_ID, v1.Connect_ID, v2.Connect_ID) = p.Connect_ID
      WHERE 
        p.d_821247024 = '197316935'      -- is verified
        AND p.d_747006172 != '353358909' -- has not widrawn consent")
# Save the query to file
write(query_a, file = glue("{outputpath}/{tier}/module1.sql"))
}