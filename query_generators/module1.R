#module 1 v1 + v2 query
generate_module1_query <- function(tier){
  
project <- switch(tier,
                    prod = "nih-nci-dceg-connect-prod-6d04",
                    stg  = "nih-nci-dceg-connect-stg-5519",
                    dev  = "nih-nci-dceg-connect-dev",
                    "unknown-environment"  # Default value if none of the cases match
)
  
library(bigrquery)
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape)  
library(stringr)
library(plyr)
library(DBI)
library(quarto)
library(arsenal)
library(glue)
library(tibble)

# Authenticate to BigQuery
bq_auth()
  
note <- "Note:
      This SQL query was generated by generate_bq2_queries.qmd. This code 
      lives in a GitHub repo (https://github.com/Analyticsphere/bq2). The 
      code was written by Jing Wu and edited by Jake Peters. The BQ2 tables 
      that are generated in this query are currated and maintained by Jake 
      Peters, Jing Wu and Rebecca Sansale. Other details will be documented here.."
  
#connect to BQ
con <- dbConnect(
    bigrquery::bigquery(),
    project = project,
    dataset = "FlatConnect",
    billing = project
)
  
table_name_v1 <- "module1_v1_JP"
table_name_v2 <- "module1_v2_JP"
sql_v1 <- glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name_v1}'")
query <- bq_project_query(project, query = sql_v1)
module1_v1_schema <- bq_table_download(query, 
                              bigint="integer64", n_max = Inf, 
                              page_size = 500, quiet = TRUE)
  
sql_v2 <- glue("SELECT * 
            FROM `{project}.FlatConnect`.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS 
            WHERE table_name='{table_name_v2}'")
query <- bq_project_query(project, query = sql_v2)
module1_v2_schema <- bq_table_download(query, 
                              bigint="integer64", n_max = Inf, 
                              page_size = 500, quiet = TRUE)

  
  #get last CID to identify PII
source("custom_r_functions/get_last_CID.R")
module1_v1_schema$last_CID <- get_last_CID(module1_v1_schema$field_path)
module1_v2_schema$last_CID <- get_last_CID(module1_v2_schema$field_path)
  
#################################################################
#################################################################
#################################################################
#the following needs to be re-written
# dd is the aggregateJSON dictionary (not up to date, but useful for labelling)
dictionary <- 
  rio::import(
    "https://episphere.github.io/conceptGithubActions/aggregateCopy.json",
    format = "json")
dd  <- dplyr::bind_rows(dictionary, .id="CID")
dd$`Variable Label` <- ifelse(is.na(dd$`Variable Label`), 
                              dd$`Variable Name`, 
                              dd$`Variable Label`)
dt_pii <- rbind(module1_v1_schema, module1_v2_schema)
dt_pii_dd <- merge(dt_pii, dd, by.x = "last_CID", by.y = "conceptId.3", all.x = TRUE)

schem_m1_v1  <- module1_v1_schema
schem_m1_v2  <- module1_v2_schema



  #these variables had formatting issues and must be called into the query
  #separately and coalesced. see github BQ2 repo issue #4 for more info
  #these are only included in module 1 v2
  exceptions_m1_v2 <- c(
    "D_150352141_D_623218391", "D_150352141_D_206625031",
    "D_150352141_D_802622485", "D_150352141_D_261863326",
    "D_122887481_D_623218391", "D_122887481_D_206625031",
    "D_122887481_D_802622485", "D_122887481_D_261863326",
    "D_534007917_D_623218391", "D_534007917_D_206625031",
    "D_534007917_D_802622485", "D_534007917_D_261863326",
    "D_752636038_D_623218391", "D_752636038_D_206625031",
    "D_752636038_D_802622485", "D_752636038_D_261863326",
    "D_518750011_D_623218391", "D_518750011_D_206625031",
    "D_518750011_D_802622485", "D_518750011_D_261863326",
    "D_275770221_D_623218391", "D_275770221_D_206625031",
    "D_275770221_D_802622485", "D_275770221_D_261863326",
    "D_527057404_D_623218391", "D_527057404_D_206625031",
    "D_527057404_D_802622485", "D_527057404_D_261863326"
  )
  

  
  # Save text files of these variable lists if desired
  if (export_lists_of_variables) {
    
    write.table(paste(m1_common.vars, collapse=",\n"),
                glue("{outputpath}/{tier}/m1_common_variables.txt"), 
                sep = "\t", row.names = F, quote = F)
    
    write.table(paste(V1_only_vars, collapse = ", \nv1."),
                glue("{outputpath}/{tier}/m1_v1_only_variables.txt"), 
                sep = "\t", row.names = F, quote = F, col.names = F)
    
    write.table(paste(V2_only_vars, collapse = ", \nv2."),
                glue("{outputpath}/{tier}/m1_v2_only_variables.txt"), 
                sep = "\t", row.names = F, quote = F, col.names = F)
  }
  
  
  ## BEGIN BUILDING THE MODULE 1 QUERY ##
  
  # Build string of variables to select that are common to both versions,
  # unique to v1 and unique to v2
  selectm1_dup     <- paste(m1_common.vars[which(m1_common.vars %nin% common_pii)], 
                            collapse = ",\n\t")
  select_m1v1_only <- paste(V1_only_vars[which(V1_only_vars %nin% v1_only_pii)], 
                            collapse = ", \n\tv1.")
  select_m1v2_only <- paste(V2_only_vars[which(V2_only_vars %nin% v2_only_pii)],
                            collapse = ", \n\tv2.")
  
  # Get the individuals who completed version 1 and version 2
  sql <- glue("SELECT DISTINCT Connect_ID
             FROM `{project}.FlatConnect.module1_v1_JP`
             WHERE Connect_ID IN (
               SELECT DISTINCT Connect_ID
               FROM `{project}.FlatConnect.module1_v2_JP`)")
  query <- bq_project_query(project, query = sql)
  compl_m1v1_and_m1v2 <- bq_table_download(query, 
                                           bigint="integer64", n_max = Inf, 
                                           page_size = 500, quiet = TRUE)
  
  # Transform the vector into the desired string format to be inserted into SQL
  completed_m1v1_and_m1v2 <- 
    paste0("'", paste(compl_m1v1_and_m1v2$Connect_ID, collapse = "',\n\t'"), "'")
  # cat(completed_m1v1_and_m1v2)
  
  description_str <- 
    "Objective:
  
      Merge Module 1 v1/v2. If participants have completed both versions, only 
      the responses to v2 will be included.
      
      For participants to be included:
       - Verification Status [821247024] MUST BE verified
       - Consent Withdrawn [747006172] MUST NOT be YES [353358909]"
  # Transform the flat vector into pairs
  v2_exceptions_m1_v2 <- paste0("v2.", exceptions_m1_v2)
  variable_pairs <- matrix(v2_exceptions_m1_v2, ncol = 2, byrow = TRUE)
  
  # Apply create_coalesce_query to each pair
  coalesce_statements <- apply(variable_pairs, 1, function(pair) {
    create_coalesce_query(pair, pair[1])
  })
  
  # Concatenate all coalesce statements
  coalesce_strings <- paste(coalesce_statements, collapse = ",\n\t")
  
  
  # Construct parameterized query for Module 1
  query_a <- glue(
    "
      /*
      {description_str}
      
      {note}
      */

      WITH m1_dup AS
      (SELECT 
        {selectm1_dup}, 
        2 as version
      FROM `{project}.FlatConnect.module1_v2_JP`
      UNION ALL
      SELECT
        {selectm1_dup},
        1 as version
      FROM `{project}.FlatConnect.module1_v1_JP`
      -- Remove participants that completed both v1 & v2 from the table for v1.
      WHERE Connect_ID NOT IN 
        ({completed_m1v1_and_m1v2})
      )
      SELECT 
        -- Select variables that are common to both versions
        dup.*, 
        -- Select variables that are unique to version 1
        {select_m1v1_only},
        -- Select variables that are unique to version 2
       {coalesce_strings},
        {select_m1v2_only}
      FROM m1_dup AS dup
      LEFT JOIN `{project}.FlatConnect.module1_v1_JP` AS v1
        ON dup.Connect_ID = v1.Connect_ID
      LEFT JOIN	`{project}.FlatConnect.module1_v2_JP` AS v2
        ON v2.Connect_ID = coalesce(dup.Connect_ID,v1.Connect_ID)
      INNER JOIN `{project}.FlatConnect.participants_JP` AS p
        ON coalesce(dup.Connect_ID, v1.Connect_ID, v2.Connect_ID) = p.Connect_ID
      WHERE 
        p.d_821247024 = '197316935'      -- is verified
        AND p.d_747006172 != '353358909' -- has not widrawn consent")
  # Save the query to file
  write(query_a, file = glue("{outputpath}/{tier}/bq2_module1.sql"))
}